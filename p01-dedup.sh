#!/bin/bash
# Script Name: photos-01-dedup.sh
# Description: Deduplicates files based on name, size, and checksum.

# Exit on error, treat unset variables as an error
set -e
set -u

# --- Source Common Configuration ---
# Assumes photo_workflow_config.sh is in the same directory as this script
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" &> /dev/null && pwd)"
# shellcheck source=./photo_workflow_config.sh
source "${SCRIPT_DIR}/photo_workflow_config.sh"
# --- End Source Common Configuration ---


# --- Script-Specific Configuration ---
readonly SCRIPT_MODULE_PREFIX="p01-dedup" # Prefix for files generated by THIS script module
readonly CHECKSUM_CMD="md5sum"
# --- End Script-Specific Configuration ---


# Ensure we're in a sane environment (LC_ALL might also be in config if truly global)
LC_ALL=C
export LC_ALL

# Check for necessary commands (some could be in config's check_commands)
check_commands "$CHECKSUM_CMD" stat find basename sort uniq awk cut mktemp rm grep wc tr
# Specific stat check (could also be a function in config)
if ! stat -c%s . &> /dev/null && ! stat -f%z . &> /dev/null ; then
    echo "Error: stat command not working as expected (GNU/Linux 'stat -c%s' or macOS 'stat -f%z' needed)." >&2
    exit 1
fi

# --- Workspace Directory Setup (uses GLOBAL_WORKSPACE_DIR_NAME from config) ---
WORKSPACE_DIR="${PWD}/${GLOBAL_WORKSPACE_DIR_NAME}" # PWD ensures it's relative to where script is run

mkdir -p "$WORKSPACE_DIR" # Ensure workspace exists
if [[ ! -d "$WORKSPACE_DIR" ]]; then
    echo "Error: Could not create workspace directory: $WORKSPACE_DIR" >&2
    exit 1
fi
echo "All output files from this module will be stored in workspace: $WORKSPACE_DIR" >&2
echo "(Using prefix: ${SCRIPT_MODULE_PREFIX})" >&2


# --- Define File Paths (Corrected Naming Convention) ---

# Stage 1: Hashing (Internal Step 01)
readonly FILE_ALL_INFO_HASHED="${WORKSPACE_DIR}/${SCRIPT_MODULE_PREFIX}-step01-all_files_hashed.tsv"
readonly FILE_HASHING_COMPLETE_MARKER="${WORKSPACE_DIR}/${SCRIPT_MODULE_PREFIX}-step01-hashing_complete.marker"

# Stage 2: Deduplication (Internal Step 02 for sorting, produces Action 01)
readonly FILE_SORTED_FOR_DEDUP="${WORKSPACE_DIR}/${SCRIPT_MODULE_PREFIX}-step02-sorted_for_dedup.tsv"
readonly ACTION_RM_DUPLICATES_SH="${WORKSPACE_DIR}/${SCRIPT_MODULE_PREFIX}-action01-deduplicate_commands.sh"

# Stage 3: Conflicting Versions Report (Internal Step 03 for prep, produces Report 01)
readonly FILE_PREPARED_FOR_CONFLICT_CHECK="${WORKSPACE_DIR}/${SCRIPT_MODULE_PREFIX}-step03-prepared_for_conflict_check.tsv"
readonly REPORT_CONFLICTING_VERSIONS_TXT="${WORKSPACE_DIR}/${SCRIPT_MODULE_PREFIX}-report01-conflicting_versions.txt"


# --- Stage 1: Single-Pass Hashing with Progress (Restartable) ---
echo "" # Blank line for readability
echo "--- ${SCRIPT_MODULE_PREFIX}: Stage 1: File Hashing (Output: ${FILE_ALL_INFO_HASHED}) ---" >&2
skip_hashing=0
if [[ -f "$FILE_ALL_INFO_HASHED" && -f "$FILE_HASHING_COMPLETE_MARKER" ]]; then
    echo "Found existing completed hash file ($FILE_ALL_INFO_HASHED) and marker." >&2
    echo "Skipping Stage 1 (Hashing)." >&2
    actual_hashed_count=$(wc -l < "$FILE_ALL_INFO_HASHED")
    echo "Using $actual_hashed_count previously hashed files." >&2
    skip_hashing=1
else
    echo "Starting: Finding all files and performing hashing (single-threaded)..." >&2
    rm -f "$FILE_HASHING_COMPLETE_MARKER" # Remove old marker if re-hashing
    > "$FILE_ALL_INFO_HASHED"          # Overwrite/create fresh hash file

    mapfile -d $'\0' file_list < <(find . -type f -print0)
    total_files=${#file_list[@]}

    echo "Found $total_files files to process." >&2
    processed_files=0

    for filepath_with_prefix in "${file_list[@]}"; do
        filepath="$filepath_with_prefix"
        filename=$(basename "$filepath")

        if ! filesize=$(stat -c%s "$filepath" 2>/dev/null); then
            if ! filesize=$(stat -f%z "$filepath" 2>/dev/null); then
                echo "Warning (Hashing): Could not get size for '$filepath'. Skipping." >&2
                processed_files=$((processed_files + 1)); continue
            fi
        fi
        checksum=$("$CHECKSUM_CMD" "$filepath" | awk '{print $1}')
        if [[ -z "$checksum" ]]; then
            echo "Warning (Hashing): Could not calculate checksum for '$filepath'. Skipping." >&2
            processed_files=$((processed_files + 1)); continue
        fi

        printf "%s%s%s%s%s%s%s\n" "$filepath" "$SEP" "$filename" "$SEP" "$filesize" "$SEP" "$checksum" >> "$FILE_ALL_INFO_HASHED"
        processed_files=$((processed_files + 1))

        if [[ $total_files -gt 0 ]]; then
            percentage=$((processed_files * 100 / total_files))
            printf "\rHashing progress: %d%% (%d/%d files)" "$percentage" "$processed_files" "$total_files" >&2
        fi
    done
    printf "\n" >&2 # Newline after progress bar

    if [[ ! -s "$FILE_ALL_INFO_HASHED" ]]; then
        echo "Error: No files were successfully hashed or no files found after Stage 1." >&2
        echo "Workspace: $WORKSPACE_DIR" >&2
        exit 1
    fi
    actual_hashed_count=$(wc -l < "$FILE_ALL_INFO_HASHED")
    echo "Successfully processed and hashed $actual_hashed_count files." >&2
    date > "$FILE_HASHING_COMPLETE_MARKER" # Create completion marker
    echo "Hashing complete. Marker file created: $FILE_HASHING_COMPLETE_MARKER" >&2
fi
echo "--- ${SCRIPT_MODULE_PREFIX}: Stage 1 Complete ---" >&2
echo "" >&2


# --- Stage 2: Deduplication ---
echo "--- ${SCRIPT_MODULE_PREFIX}: Stage 2: Deduplication Analysis (Action Output: ${ACTION_RM_DUPLICATES_SH}) ---" >&2
if [[ ! -s "$FILE_ALL_INFO_HASHED" ]]; then
    echo "Error: Hashed file ($FILE_ALL_INFO_HASHED) is missing or empty. Cannot proceed with Stage 2." >&2
    exit 1
fi

# Input: path<SEP>name<SEP>size<SEP>checksum
# Output for sort: name<SEP>size<SEP>checksum<SEP>path
awk -F"$SEP" '{print $2 FS $3 FS $4 FS $1}' "$FILE_ALL_INFO_HASHED" | \
    sort -t"$SEP" -k1,1 -k2,2n -k3,3 -k4,4 > "$FILE_SORTED_FOR_DEDUP"

if [[ ! -s "$FILE_SORTED_FOR_DEDUP" ]]; then
    echo "Error: Failed to sort hashed file info for deduplication ($FILE_SORTED_FOR_DEDUP), or result is empty." >&2
    exit 1
fi

true > "$ACTION_RM_DUPLICATES_SH" # Create/clear action script
any_duplicates_found_for_rm=0

awk -F"$SEP" -v outfile="$ACTION_RM_DUPLICATES_SH" '
{
    # Input: name FS size FS checksum FS path
    current_name = $1
    current_size = $2
    current_checksum = $3
    current_path = $4
    current_key = current_name FS current_size FS current_checksum

    if (NR > 1 && current_key == prev_key) {
        if (! (prev_key in header_printed_dedup) ) {
            printf "# Duplicate set for: Name: %s, Size: %s, Checksum: %s\n", prev_name_for_header, prev_size_for_header, prev_checksum_for_header >> outfile
            printf "# Keeping: \047%s\047\n", path_to_keep >> outfile
            header_printed_dedup[prev_key] = 1
        }
        printf "rm \"%s\"\n", current_path >> outfile
        output_generated_for_key_dedup = 1
        overall_output_generated_dedup = 1
    } else {
        if (NR > 1 && output_generated_for_key_dedup) {
            printf "\n" >> outfile
        }
        path_to_keep = current_path
        prev_name_for_header = current_name
        prev_size_for_header = current_size
        prev_checksum_for_header = current_checksum
        output_generated_for_key_dedup = 0
    }
    prev_key = current_key
}
END {
    if (output_generated_for_key_dedup) {
        printf "\n" >> outfile
    }
    if (!overall_output_generated_dedup) {
        print "# No duplicate files (by name, size, and checksum) found to list for removal." > "/dev/stderr"
    }
    exit (overall_output_generated_dedup ? 0 : 1)
}
' "$FILE_SORTED_FOR_DEDUP"

dedup_awk_exit_status=$?
if [[ $dedup_awk_exit_status -eq 0 ]]; then
    any_duplicates_found_for_rm=1
    echo "Generated 'rm' commands for duplicates in: $ACTION_RM_DUPLICATES_SH" >&2
else
    echo "No true duplicate files found to remove (name, size, and checksum match)." >&2
fi
echo "--- ${SCRIPT_MODULE_PREFIX}: Stage 2 Complete ---" >&2
echo "" >&2


# --- Stage 3: Report on Files with Same Name but Different Checksums (All Files Pre-Delete) ---
echo "--- ${SCRIPT_MODULE_PREFIX}: Stage 3: Conflicting Versions Report (Report Output: ${REPORT_CONFLICTING_VERSIONS_TXT}) ---" >&2
if [[ ! -s "$FILE_ALL_INFO_HASHED" ]]; then
    echo "Error: Hashed file ($FILE_ALL_INFO_HASHED) is missing or empty. Cannot proceed with Stage 3." >&2
    exit 1
fi

# Prepare data for conflict check: name<SEP>checksum<SEP>path<SEP>size
awk -F"$SEP" '{print $2 FS $4 FS $1 FS $3}' "$FILE_ALL_INFO_HASHED" > "$FILE_PREPARED_FOR_CONFLICT_CHECK"
sort -t"$SEP" -k1,1 -k2,2 "$FILE_PREPARED_FOR_CONFLICT_CHECK" -o "$FILE_PREPARED_FOR_CONFLICT_CHECK" # Sort in place

if [[ ! -s "$FILE_PREPARED_FOR_CONFLICT_CHECK" ]]; then
    echo "Error: Failed to prepare data for conflict check ($FILE_PREPARED_FOR_CONFLICT_CHECK), or result is empty." >&2
else
    true > "$REPORT_CONFLICTING_VERSIONS_TXT" # Create/clear report file
    any_conflicting_versions_found=0

    awk -F"$SEP" -v outfile="$REPORT_CONFLICTING_VERSIONS_TXT" '
    {
        # Input: name FS checksum FS path FS size
        name = $1
        checksum = $2
        path = $3
        size = $4

        instances_count[name]++
        idx = instances_count[name]
        paths[name, idx] = path
        checksums[name, idx] = checksum
        sizes[name, idx] = size
        unique_checksums_for_name[name, checksum] = 1
    }
    END {
        report_generated_conflict_awk = 0
        for (name in instances_count) {
            num_distinct_checksums = 0
            for (cs_key in unique_checksums_for_name) {
                split(cs_key, parts, SUBSEP)
                if (parts[1] == name) {
                    num_distinct_checksums++
                }
            }

            if (num_distinct_checksums > 1) {
                report_generated_conflict_awk = 1
                printf "Filename: \047%s\047 has %d different versions (based on checksum):\n", name, num_distinct_checksums >> outfile
                for (i = 1; i <= instances_count[name]; i++) {
                    printf "  - Checksum: %s, Size: %s, Path: \047%s\047\n", checksums[name, i], sizes[name, i], paths[name, i] >> outfile
                }
                print "" >> outfile
            }
        }

        if (!report_generated_conflict_awk) {
            print "No files found with the same name but having instances with different checksums (all files considered)." >> outfile
        }
        exit (report_generated_conflict_awk ? 0 : 1)
    }
    ' "$FILE_PREPARED_FOR_CONFLICT_CHECK"

    conflict_awk_exit_status=$?
    if [[ $conflict_awk_exit_status -eq 0 ]]; then
        any_conflicting_versions_found=1
        echo "Generated report on conflicting versions (all files) in: $REPORT_CONFLICTING_VERSIONS_TXT" >&2
    else
        echo "No files with same name but different checksum instances found (all files considered)." >&2
    fi
fi
echo "--- ${SCRIPT_MODULE_PREFIX}: Stage 3 Complete ---" >&2
echo "" >&2


# --- Final Summary ---
echo "--- ${SCRIPT_MODULE_PREFIX}: Summary ---" >&2
echo "All output files (intermediate, reports, actions) from this module are stored in the single workspace directory:" >&2
echo "   ${WORKSPACE_DIR}" >&2
echo "" >&2

if [[ $any_duplicates_found_for_rm -eq 1 ]]; then
    echo "-> Deduplication Action: 'rm' commands to remove true duplicates are in:" >&2
    echo "   ${ACTION_RM_DUPLICATES_SH}" >&2
    echo "   To execute: cd to the original directory and run 'bash \"${ACTION_RM_DUPLICATES_SH}\"'" >&2
else
    echo "-> Deduplication Action: No true duplicate files (same name, size, checksum) were found to remove." >&2
fi
echo "" >&2

if [[ -f "$REPORT_CONFLICTING_VERSIONS_TXT" ]]; then
    if [[ $any_conflicting_versions_found -eq 1 ]]; then
        echo "-> Conflicting Versions Report: Files with the same name but instances with different checksums are listed in:" >&2
        echo "   ${REPORT_CONFLICTING_VERSIONS_TXT}" >&2
    else
        echo "-> Conflicting Versions Report: No files with the same name but different checksum instances were found (all files considered)." >&2
        echo "   (Report file ${REPORT_CONFLICTING_VERSIONS_TXT} will state this)." >&2
    fi
else
    echo "-> Conflicting Versions Report: Not generated (likely due to no files processed or errors in Stage 3)." >&2
fi
echo "" >&2
echo "--- ${SCRIPT_MODULE_PREFIX}: Processing Complete ---" >&2
exit 0
